// Handles additional code and business logic for auth matters.

const dbClient = require('../utils/db').dbClient;
const emailValidator = require('deep-email-validator');

/**
 * Check if the passed argument is a valid name.
 * The name is checked to be a string and not empty.
 * @param {String} name the name to validate
 */
function isValidName(name, isUsername=false) {
    if (name) {
        if (name.length > 0) {
            return true;
        }
    }
    
    return false;
}

/**
 * Validates an email address using deep-email-validator.
 * Validates that:
 *      - email looks like one, eg. with '@' and '.' to the right.
 *      - common email typos using `mailcheck`.
 *      - email was not generated by a disposable email service, using
 *        `disposable-email-domains` module.
 *      - mx records are present on DNS.
 *      - SMTP server is running.
 *      - mailbox exists on SMTP server.
 * @requires deep-email-validator module.
 * @param {String} email the email to validate
 * Returns true if valid, otherwise false
 */
async function isValidEmail(email) {
    try {
        return await emailValidator.validate(email);
    } catch (error) {
        console.log(`Error while validating email: ${error}`);
    }
}

/**
 * Performs password validation according to the following specifications:
 * Contains at least:
 * - One uppercase letter
 * - One lowercase letter
 * - One special character
 * - One digit
 * - A total length of 8 characters
 * @param {String} password the password to validate
 * Returns true if validate, otherwise false.
 */
function isValidPassword(password) {
    if (typeof password !== 'string') {
        return false;
    }
    if (password.length < 8) {
        return false;
    }

    let hasUpperCase = false;
    let hasLowerCase = false;
    let hasSpecialChar = false;
    let hasNumber = false;

    for (const char of password) {
        if (hasUpperCase && hasLowerCase && hasSpecialChar && hasNumber) {
            return true;
        } else if (char >= 'A' && char <= 'Z') {
            hasUpperCase = true;
        } else if (char >= 'a' && char <= 'z') {
            hasLowerCase = true;
        } else if ('!@#$%^&*()_-+=?/<>{}[]|'.includes(char)) {
            hasSpecialChar = true;
        } else if (/^\d$/.test(char)) {
            hasNumber = true;
        }
    }

    return (hasUpperCase && hasLowerCase && hasSpecialChar && hasNumber);
}

/**
 * Searches for an existing user with the given email.
 * @param {String} email unique email used to find an existing user
 * @returns the user if found, otherwise null.
 */
async function findUser(email) {
    return await dbClient.findUser('email', email);
}

/**
 * Generates a friendly ID for a user, based off their username.
 * the username removes all special characters and converts all
 * uppercase to lowercase.
 * `username` is expected to be validated beforehand.
 * @param {String} username the username of the user.
 */
function generateFriendlyId(username) {
    try {
        const cleanUsername = username.toLowerCase().replace(/[^a-z0-9]/g, '');
        const randomString = Math.random().toString(36).substring(2, 7);
        
        return `${cleanUsername}-${randomString}`;
    } catch (error) {
        console.log(`Error while generating a friendly ID: ${error}`);
        return null;
    }
}

/**
 * Inserts one user into the database.
 * @param {Object} userInfo the information of the new user.
 */
async function insertUser(userInfo) {
    const result = await dbClient.insertUser(userInfo);
    return result;
}

/* 
Could you give me a breakdown of how I would implement the schema 
validation and if it is preferred? Also would it be wise to make the 
recipe collection have these fields: name, ingredients, cooking-time, 
and instructions; the 'instructions' field being a large string text 
with all the instructions of making the recipe? Another thing I would 
like to know is about the ObjectIds generated for each user and recipe 
record. Earlier, I inquired about them and you said that the front-end 
does not usually deal with the ObjectId of a record as it would introduce 
a security issue in accessing a record directly from the database. Thus, 
instead of returning a user or record's id, should I instead generate a 
friendly-user id t give to the front-end to handle. What is usually the 
best practice of a back-end API giving the front-end a record's id to use 
on the front-end side?
 */

module.exports = {
    isValidEmail,
    isValidPassword,
    findUser,
    generateFriendlyId,
    insertUser
}

